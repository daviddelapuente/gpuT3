import {
    ClampToEdgeWrapping,
    DataTexture,
    FloatType,
    HalfFloatType,
    LinearFilter,
    Mesh,
    NearestFilter,
    OrthographicCamera,
    PlaneBufferGeometry,
    RGBAFormat,
    RepeatWrapping,
    Scene,
    ShaderMaterial,
    UniformsUtils,
    Vector2,
    Vector3,
    WebGLRenderTarget
} from "../../../build/three.module.js";
import { OceanShaders } from "../shaders/OceanShaders.js";
import {Ocean} from "three/examples/jsm/misc/Ocean";

var Terreno = function ( renderer, camera, scene, options ) {
    // flag used to trigger parameter changes
    this.changed = true;
    this.initial = true;

    // Assign required parameters as object properties
    this.terrenoCamera = new OrthographicCamera(); //camera.clone();
    this.terrenoCamera.position.z = 1;
    this.renderer = renderer;
    this.renderer.clearColor( 0xffffff );

    this.scene = new Scene();

    // Assign optional parameters as variables and object properties
    function optionalParameter( value, defaultValue ) {
        return value !== undefined ? value : defaultValue;
    }

    options = options || {};
    this.clearColor = optionalParameter( options.CLEAR_COLOR, [ 1.0, 1.0, 1.0, 0.0 ] );
    this.geometryOrigin = optionalParameter( options.GEOMETRY_ORIGIN, [ - 1000.0, - 1000.0 ] );
    this.sunDirectionX = optionalParameter( options.SUN_DIRECTION[ 0 ], - 1.0 );
    this.sunDirectionY = optionalParameter( options.SUN_DIRECTION[ 1 ], 1.0 );
    this.sunDirectionZ = optionalParameter( options.SUN_DIRECTION[ 2 ], 1.0 );
    this.colorTerreno = optionalParameter( options.COLOR_TERRENO, new Vector3( 0.004, 0.016, 0.047 ) );
    this.skyColor = optionalParameter( options.SKY_COLOR, new Vector3( 3.2, 9.6, 12.8 ) );
    this.exposure = optionalParameter( options.EXPOSURE, 0.35 );
    this.geometryResolution = optionalParameter( options.GEOMETRY_RESOLUTION, 32 );
    this.geometrySize = optionalParameter( options.GEOMETRY_SIZE, 2000 );
    this.resolution = optionalParameter( options.RESOLUTION, 64 );
    this.floatSize = optionalParameter( options.SIZE_OF_FLOAT, 4 );
    this.size = optionalParameter( options.INITIAL_SIZE, 250.0 );

    //
    this.matrixNeedsUpdate = false;

    // Setup framebuffer pipeline
    var renderTargetType = optionalParameter( options.USE_HALF_FLOAT, false ) ? HalfFloatType : FloatType;
    var LinearClampParams = {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping,
        format: RGBAFormat,
        stencilBuffer: false,
        depthBuffer: false,
        premultiplyAlpha: false,
        type: renderTargetType
    };
    var NearestClampParams = {
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        wrapS: ClampToEdgeWrapping,
        wrapT: ClampToEdgeWrapping,
        format: RGBAFormat,
        stencilBuffer: false,
        depthBuffer: false,
        premultiplyAlpha: false,
        type: renderTargetType
    };
    var NearestRepeatParams = {
        minFilter: NearestFilter,
        magFilter: NearestFilter,
        wrapS: RepeatWrapping,
        wrapT: RepeatWrapping,
        format: RGBAFormat,
        stencilBuffer: false,
        depthBuffer: false,
        premultiplyAlpha: false,
        type: renderTargetType
    };
    this.initialSpectrumFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestRepeatParams );
    this.spectrumFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
    this.pingPhaseFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
    this.pongPhaseFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
    this.pingTransformFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
    this.pongTransformFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
    this.displacementMapFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );
    this.normalMapFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );
















    // 7 - Shader used to update normals
    var terrenoShader = OceanShaders[ "ocean_main" ];
    var terrenoUniforms = UniformsUtils.clone( terrenoShader.uniforms );
    this.materialTerreno = new ShaderMaterial( {
        uniforms: terrenoUniforms,
        vertexShader: terrenoShader.vertexShader,
        fragmentShader: terrenoShader.fragmentShader
    } );
    this.materialTerreno.uniforms.u_geometrySize = { value: this.resolution };
    this.materialTerreno.uniforms.u_displacementMap = { value: this.displacementMapFramebuffer.texture };
    this.materialTerreno.uniforms.u_normalMap = { value: this.normalMapFramebuffer.texture };
    this.materialTerreno.uniforms.u_terrenoColor = { value: this.terrenoColor };
    this.materialTerreno.uniforms.u_skyColor = { value: this.skyColor };
    this.materialTerreno.uniforms.u_sunDirection = { value: new Vector3( this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ ) };
    this.materialTerreno.uniforms.u_exposure = { value: this.exposure };
    this.materialTerreno.blending = 0;

    // Generate the terreno mesh
    this.generateMesh();
};

Terreno.prototype.generateMesh = function () {
    var geometry = new PlaneBufferGeometry( this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution );
    geometry.rotateX( - Math.PI / 2 );
    this.terrenoMesh = new Mesh( geometry, this.materialTerreno );

};

Ocean.prototype.render = function () {

    var currentRenderTarget = this.renderer.getRenderTarget();

    this.scene.overrideMaterial = null;

    if ( this.changed )
        this.renderInitialSpectrum();

    this.renderWavePhase();
    this.renderSpectrum();
    this.renderSpectrumFFT();
    this.renderNormalMap();
    this.scene.overrideMaterial = null;

    this.renderer.setRenderTarget( currentRenderTarget );

};
export { Terreno };